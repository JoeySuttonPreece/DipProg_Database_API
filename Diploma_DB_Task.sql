IF OBJECT_ID('PURCHASEORDER8393') IS NOT NULL
DROP TABLE PURCHASEORDER8393;

IF OBJECT_ID('INVENTORY8393') IS NOT NULL
DROP TABLE INVENTORY8393;

IF OBJECT_ID('ORDERLINE8393') IS NOT NULL
DROP TABLE ORDERLINE8393;

IF OBJECT_ID('ORDER8393') IS NOT NULL
DROP TABLE [ORDER8393];

IF OBJECT_ID('AUTHORISEDPERSON8393') IS NOT NULL
DROP TABLE AUTHORISEDPERSON8393;

IF OBJECT_ID('ACCOUNTPAYMENT8393') IS NOT NULL
DROP TABLE ACCOUNTPAYMENT8393;

IF OBJECT_ID('CLIENTACCOUNT8393') IS NOT NULL
DROP TABLE CLIENTACCOUNT8393;

IF OBJECT_ID('PRODUCT8393') IS NOT NULL
DROP TABLE PRODUCT8393;

IF OBJECT_ID('LOCATION8393') IS NOT NULL
DROP TABLE [LOCATION8393];

IF OBJECT_ID('GENERALLEDGER8393') IS NOT NULL
DROP TABLE GENERALLEDGER8393;

GO

CREATE TABLE GENERALLEDGER8393
(
    ITEMID INTEGER,
    DESCRIPTION NVARCHAR(100),
    AMOUNT MONEY,
    CONSTRAINT PK_GENERALLEDGER PRIMARY KEY (ITEMID),
    CONSTRAINT UQ_GENERALEDGER_DESCRIPTION UNIQUE(DESCRIPTION)
);

INSERT INTO GENERALLEDGER8393
    (ITEMID, DESCRIPTION, AMOUNT)
VALUES
    (1, 'ASSETSCASH', 100000.00),
    (2, 'ASSETSSTOCK', 0),
    (3, 'ASSETSACCOUNT', 0);

CREATE TABLE [LOCATION8393]
(
    LOCATIONID NVARCHAR(8),
    LOCNAME NVARCHAR(50) NOT NULL,
    ADDRESS NVARCHAR(200) NOT NULL,
    MANAGER NVARCHAR(100),
    CONSTRAINT PK_LOCATION PRIMARY KEY (LOCATIONID)
);

CREATE TABLE PRODUCT8393
(
    PRODUCTID INTEGER IDENTITY(10001, 1),
    PRODNAME NVARCHAR(100) NOT NULL,
    BUYPRICE MONEY,
    SELLPRICE MONEY,
    CONSTRAINT PK_PRODUCT PRIMARY KEY(PRODUCTID),
    CONSTRAINT CHK_WHOLESALE_RETAIL CHECK(BUYPRICE < SELLPRICE)
);

CREATE TABLE CLIENTACCOUNT8393
(
    ACCOUNTID INTEGER IDENTITY(30001, 1),
    ACCTNAME NVARCHAR(100) NOT NULL,
    BALANCE MONEY NOT NULL,
    CREDITLIMIT MONEY NOT NULL,
    CONSTRAINT PK_CLIENTACCOUNT PRIMARY KEY(ACCOUNTID),
    CONSTRAINT CHK_CLIENTACCOUNT_BALANCE_CREDIT CHECK(BALANCE <= CREDITLIMIT),
    CONSTRAINT UQ_CLENTACCOUNT_NAME UNIQUE(ACCTNAME)
);

CREATE TABLE ACCOUNTPAYMENT8393
(
    ACCOUNTID INTEGER,
    DATETIMERECEIVED DATETIME,
    AMOUNT MONEY NOT NULL,
    CONSTRAINT PK_ACCOUNTPAYMENT PRIMARY KEY(ACCOUNTID, DATETIMERECEIVED),
    CONSTRAINT FK_ACCOUNTPAYMENT_ACCOUNT FOREIGN KEY (ACCOUNTID) REFERENCES CLIENTACCOUNT8393,
    CONSTRAINT CHK_ACCOUNTPAYMENT_AMOUNT CHECK(AMOUNT > 0)
);

CREATE TABLE AUTHORISEDPERSON8393
(
    USERID INTEGER IDENTITY(50001, 1),
    FIRSTNAME NVARCHAR(100) NOT NULL,
    SURNAME NVARCHAR(100) NOT NULL,
    EMAIL NVARCHAR(100) NOT NULL,
    [PASSWORD] NVARCHAR(100) NOT NULL,
    ACCOUNTID INTEGER NOT NULL,
    CONSTRAINT PK_AUTHORISEDPERSON PRIMARY KEY(USERID),
    CONSTRAINT FK_AUTHORISEDPERSON_CLIENTACCOUNT FOREIGN KEY(ACCOUNTID) REFERENCES CLIENTACCOUNT8393,
    CONSTRAINT CHK_AUTHORISEDPERSON_EMAIL CHECK(EMAIL LIKE '%@%')
);

CREATE TABLE [ORDER8393]
(
    ORDERID INTEGER IDENTITY(70001, 1),
    SHIPPINGADDRESS NVARCHAR(200) NOT NULL,
    DATETIMECREATED DATETIME NOT NULL,
    DATETIMEDISPATCHED DATETIME,
    TOTAL MONEY NOT NULL,
    USERID INTEGER NOT NULL,
    CONSTRAINT PK_ORDER PRIMARY KEY(ORDERID),
    CONSTRAINT FK_ORDER_AUTHORISEDPERSON FOREIGN KEY(USERID) REFERENCES AUTHORISEDPERSON8393,
    CONSTRAINT CHK_ORDER_TOTAL CHECK(TOTAL >= 0)
);


CREATE TABLE ORDERLINE8393
(
    ORDERID INTEGER,
    PRODUCTID INT,
    QUANTITY INT NOT NULL,
    DISCOUNT DECIMAL(5, 4) DEFAULT 0,
    SUBTOTAL MONEY NOT NULL,
    CONSTRAINT PK_ORDERLINE PRIMARY KEY(ORDERID, PRODUCTID),
    CONSTRAINT FK_ORDERLINE_ORDER FOREIGN KEY(ORDERID) REFERENCES [ORDER8393],
    CONSTRAINT FK_ORDERLINE_PRODUCT FOREIGN KEY(PRODUCTID) REFERENCES PRODUCT8393,
    CONSTRAINT CHK_ORDER_DISCOUNT CHECK(DISCOUNT >= 0 AND DISCOUNT <= 0.25),
    CONSTRAINT CHK_ORDERLINE_SUBTOTAL CHECK(SUBTOTAL > 0)
);

CREATE TABLE INVENTORY8393
(
    PRODUCTID INT,
    LOCATIONID NVARCHAR(8),
    NUMINSTOCK INTEGER NOT NULL,
    CONSTRAINT PK_INVENTORY PRIMARY KEY(PRODUCTID, LOCATIONID),
    CONSTRAINT FK_INVENTORY_PRODUCT FOREIGN KEY(PRODUCTID) REFERENCES PRODUCT8393,
    CONSTRAINT FK_INVENTORY_LOCATION FOREIGN KEY(LOCATIONID) REFERENCES LOCATION8393,
    CONSTRAINT CHK_INVENTORY_NUMINSTOCK CHECK(NUMINSTOCK >= 0)
);

CREATE TABLE PURCHASEORDER8393
(
    PRODUCTID INT,
    LOCATIONID NVARCHAR(8),
    DATETIMECREATED DATETIME,
    QUANTITY INTEGER,
    TOTAL MONEY,
    CONSTRAINT PK_PURCHASEORDER PRIMARY KEY(PRODUCTID, LOCATIONID, DATETIMECREATED),
    CONSTRAINT FK_PURCHASEORDER_PRODUCT FOREIGN KEY(PRODUCTID) REFERENCES PRODUCT8393,
    CONSTRAINT FK_PURCHASEORDER_LOCATION FOREIGN KEY(LOCATIONID) REFERENCES LOCATION8393,
    CONSTRAINT CHK_PURCHASEORDER_QUANTITY CHECK(QUANTITY > 0)
);

GO


--SELECT * FROM SYS.TABLES;

--------------------------
/*
-- SET UP LOCATION, PRODUCT AND INVENTORY
BEGIN

    INSERT INTO LOCATION8393
        (LOCATIONID, LOCNAME, ADDRESS, MANAGER)
    VALUES
        ('MLB3931', 'Melbourne South East', '123 Demon Street, Mornington, 3931', 'Bruce Wayne');

    INSERT INTO PRODUCT8393
        (PRODNAME, BUYPRICE, SELLPRICE)
    VALUES
        ('APPLE ME PHONE X', '890.00', 1295.00 );

    DECLARE @PRODID INT = @@IDENTITY;

    INSERT INTO INVENTORY8393
        (PRODUCTID, LOCATIONID, NUMINSTOCK)
    VALUES
        (@PRODID, 'MLB3931', 0);

    -- ADD A NEW CLIENT ACCOUNT AND A NEW AUTHORISED USER FOR THAT ACCOUNT

    INSERT INTO CLIENTACCOUNT8393
        (ACCTNAME, BALANCE, CREDITLIMIT)
    VALUES
        ('FREDS LOCAL PHONE STORE', '0', 10000.00 );

    DECLARE @ACCOUNTID INT = @@IDENTITY;

    INSERT INTO AUTHORISEDPERSON8393
        (FIRSTNAME, SURNAME, EMAIL, [PASSWORD], ACCOUNTID)
    VALUES
        ('Fred', 'Flintstone', 'fred@fredsphones.com', 'secret', @ACCOUNTID);

    DECLARE @USERID INT = @@IDENTITY;

    -----------

    -- BUY SOME STOCK

    -- ADD A PURCHASE ORDER ROW
    INSERT INTO PURCHASEORDER8393
        (PRODUCTID, LOCATIONID, DATETIMECREATED, QUANTITY, TOTAL)
    VALUES
        (@PRODID, 'MLB3931', '10-Apr-2020', 50, 44500.00);

    -- UPDATE OUR INVENTORY FOR THAT STOCK
    UPDATE INVENTORY8393 SET NUMINSTOCK = 50 WHERE PRODUCTID = @PRODID AND LOCATIONID = 'MLB3931';

    -- UPDATE THE GENERAL LEDGER INCREASING THE VALUE OF OUR STOCK ASSETS AND DECREASING THE CASH ASSETS
    UPDATE GENERALLEDGER8393 SET AMOUNT = AMOUNT - 44500.00 WHERE DESCRIPTION = 'ASSETSCASH';
    UPDATE GENERALLEDGER8393 SET AMOUNT = AMOUNT + 44500.00 WHERE DESCRIPTION = 'ASSETSSTOCK';

    -----------

    -- CUSTOMER MAKES AN ORDER - (INITIALLY THE ORDER IS NOT FULFILLED)

    INSERT INTO ORDER8393
        (SHIPPINGADDRESS, DATETIMECREATED, DATETIMEDISPATCHED, TOTAL, USERID)
    VALUES
        ('7 Lucky Strike, Bedrock, USB, 1111', '20-Apr-2020', NULL, 6151.25, @USERID);

    DECLARE @ORDERID INT = @@IDENTITY;

    INSERT INTO ORDERLINE8393
        (ORDERID, PRODUCTID, QUANTITY, DISCOUNT, SUBTOTAL)
    VALUES
        (@ORDERID, @PRODID, 5, 0.05, '6151.25');

    -- WE FULLFILL THE ORDER

    -- UPDATE THE ORDER TO GIVE IT A FULLFUILLED DATE
    UPDATE ORDER8393 SET DATETIMEDISPATCHED = '21-Apr-2020' WHERE ORDERID = @ORDERID;

    -- UPDATE THE CLIENTS ACCOUNT BALANCE TO INCLUDE THE VALUE OF THE ORDER
    UPDATE CLIENTACCOUNT8393 SET BALANCE = BALANCE + 6151.25 WHERE ACCOUNTID = @ACCOUNTID;

    -- UPDATE THE GENERAL LEDGER INCREASING VALUE OF ACCOUNTS, DECEASING VALUE OF STOCK
    UPDATE GENERALLEDGER8393 SET AMOUNT = AMOUNT + 6151.25  WHERE DESCRIPTION = 'ASSETSACCOUNT';
    UPDATE GENERALLEDGER8393 SET AMOUNT = AMOUNT - (5*890) WHERE DESCRIPTION = 'ASSETSSTOCK';

    -------------

    -- CLIENT MAKES AN ACCOUNT OFF THIER ACCOUNT BALANCE

    -- ADD A ROW TO ACCOUNTPAYMENT8393
    INSERT INTO ACCOUNTPAYMENT8393
        (ACCOUNTID, DATETIMERECEIVED, AMOUNT)
    VALUES
        (@ACCOUNTID, '25-Apr-2020', '2000.00');

    -- UPDATE THE CLIENT ACCOUNT TO REFLECT THE BALANCE CHANGE
    UPDATE CLIENTACCOUNT8393 SET BALANCE = BALANCE - 2000.00 WHERE ACCOUNTID = @ACCOUNTID;

    -- UPDATE THE GENERAL LEDGER - INCREASE ASSETSCASH AND DECREASE ASSETS ACCOUNT
    UPDATE GENERALLEDGER8393 SET AMOUNT = AMOUNT + 2000.00 WHERE DESCRIPTION = 'ASSETSCASH';
    UPDATE GENERALLEDGER8393 SET AMOUNT = AMOUNT - 2000.00 WHERE DESCRIPTION = 'ASSETSACCOUNT';
END;

GO
*/
----------------------------

IF OBJECT_ID('ADD_LOCATION') IS NOT NULL
DROP PROCEDURE ADD_LOCATION;

GO

CREATE PROCEDURE ADD_LOCATION
    @PLOCID NVARCHAR(8),
    @PLOCNAME NVARCHAR(50),
    @PLOCADDRESS NVARCHAR(200),
    @PMANAGER NVARCHAR(100)
AS
BEGIN
    -- THE FOLLOWING MUST BE COMPLETED AS A SINGLE TRANSACTION
    -- insert the specified values into the table LOCATION8393
    -- ADD A ROW FOR THIS LOCATION TO THE INVENTORY8393 TABLE **FOR EACH** PRODUCT IN THE PRODUCT8393 TABLE
    -- I.E. IF THERE ARE 4 PRODUCTS THIS WILL BE 4 NEW ROWS IN THE INVENTORY TABLE
    -- RETURN THE LOCID OF THE NEW LOCATION

    -- EXCEPTIONS
    -- if the location id is a duplicate throw error: number 51001  message : 'Duplicate Location ID'
    -- for any other errors throw error : number 50000  message:  error_message()

    BEGIN TRY
        BEGIN TRANSACTION
            INSERT INTO LOCATION8393
            (LOCATIONID, LOCNAME, ADDRESS, MANAGER)
            VALUES
            (@PLOCID, @PLOCNAME, @PLOCADDRESS, @PMANAGER);

            INSERT INTO INVENTORY8393
            (PRODUCTID, LOCATIONID, NUMINSTOCK)
            SELECT PRODUCTID, @PLOCID, 0
            FROM PRODUCT8393 AS P;
        COMMIT
    END TRY
    BEGIN CATCH
        if ERROR_NUMBER() = 2627
            THROW 51001, 'DUPLICATE LOCATION ID', 1;
        ELSE
            BEGIN
        DECLARE @ERRORMESSAGE NVARCHAR(MAX) = ERROR_MESSAGE();
        THROW 50000, @ERRORMESSAGE, 1;
    END;
    END CATCH;
END;

GO

IF OBJECT_ID('GET_LOCATION_BY_ID') IS NOT NULL
DROP PROCEDURE GET_LOCATION_BY_ID;

GO

CREATE PROCEDURE GET_LOCATION_BY_ID
    @PLOCID NVARCHAR(8)
AS
BEGIN
    -- return the specified location.

    -- EXCEPTIONS
    -- if the location id is invalid throw error: number 51002  message : 'LOCATION DOES NOT EXIST'
    -- for any other errors throw error : number 50000  message:  error_message()

    BEGIN TRY
        IF (SELECT COUNT(*)
    FROM LOCATION8393
    WHERE LOCATIONID = @PLOCID) = 0
            THROW 51002, 'LOCATION DOES NOT EXIST', 1;
    SELECT * FROM LOCATION8393
    WHERE LOCATIONID = @PLOCID;
    END TRY
    BEGIN CATCH
        IF ERROR_NUMBER() = 51002
            THROW;
        ELSE
            BEGIN
        DECLARE @ERRORMESSAGE NVARCHAR(MAX) = ERROR_MESSAGE();
        THROW 50000, @ERRORMESSAGE, 1;
    END;
    END CATCH;
END;

GO

IF OBJECT_ID('ADD_PRODUCT') IS NOT NULL
DROP PROCEDURE ADD_PRODUCT;

GO

CREATE PROCEDURE ADD_PRODUCT
    @PPRODNAME NVARCHAR(100),
    @PBUYPRICE MONEY,
    @PSELLPRICE MONEY,
    @PRODUCTID INT OUTPUT
AS
BEGIN
    -- THE FOLLOWING MUST BE COMPLETED AS A SINGLE TRANSACTION
    -- insert the specified values into the table PRODUCT8393
    -- ADD A ROW FOR THIS PRODUCT TO THE INVENTORY8393 TABLE **FOR EACH** LOCTAION IN THE LOCATION8393 TABLE
    -- I.E. IF THERE ARE 4 LOCATIONS THIS WILL BE 4 NEW ROWS IN THE INVENTORY TABLE
    -- RETURN THE NEW PRODUCTS PRODUCTID

    -- EXCEPTIONS
    -- for any other errors throw error : number 50000  message:  error_message()

    BEGIN TRY
        BEGIN TRANSACTION
            INSERT INTO PRODUCT8393
            (PRODNAME, BUYPRICE, SELLPRICE)
            VALUES
            (@PPRODNAME, @PBUYPRICE, @PSELLPRICE);

            DECLARE @NEWID INT = SCOPE_IDENTITY()

            INSERT INTO INVENTORY8393
            (PRODUCTID, LOCATIONID, NUMINSTOCK)
            SELECT @NEWID, LOCATIONID, 0
            FROM LOCATION8393 AS P;

            SET @PRODUCTID = @NEWID;
        COMMIT
    END TRY
    BEGIN CATCH
        DECLARE @ERRORMESSAGE NVARCHAR(MAX) = ERROR_MESSAGE();
        THROW 50000, @ERRORMESSAGE, 1;
    END CATCH;

END;

GO

IF OBJECT_ID('GET_PRODUCT_BY_ID') IS NOT NULL
DROP PROCEDURE GET_PRODUCT_BY_ID;

GO

CREATE PROCEDURE GET_PRODUCT_BY_ID
    @PPRODID INT
AS
BEGIN
    -- return the specified PRODUCT.

    -- EXCEPTIONS
    -- if the PRODUCT id iis invalid throw error: number 52002  message : 'PRODUCT DOES NOT EXIST'
    -- for any other errors throw error : number 50000  message:  error_message()

    BEGIN TRY
       IF (SELECT COUNT(*)
    FROM PRODUCT8393
    WHERE PRODUCTID = @PPRODID) = 0
        THROW 52002, 'PRODUCT DOES NOT EXIST', 1;
    SELECT * FROM PRODUCT8393
    WHERE PRODUCTID = @PPRODID;
    END TRY
    BEGIN CATCH
        IF ERROR_NUMBER() = 52002
            THROW;
        ELSE
            BEGIN
        DECLARE @ERRORMESSAGE NVARCHAR(MAX) = ERROR_MESSAGE();
        THROW 50000, @ERRORMESSAGE, 1;
    END;
    END CATCH;
END;

GO

IF OBJECT_ID('PURCHASE_STOCK') IS NOT NULL
DROP PROCEDURE PURCHASE_STOCK;

GO

CREATE PROCEDURE PURCHASE_STOCK
    @PPRODID INT,
    @PLOCID NVARCHAR(8),
    @PQTY INT
AS
BEGIN
    -- THE FOLLOWING MUST BE COMPLETED AS A SINGLE TRANSACTION

    -- insert the A ROW TO THE PURCHASE ORDER TABLE
    -- USE THE CURRENT SYSTEM DATETIME AS FOR THE DATETIMECREATED FIELD
    -- CALCULATE THE TOTAL BASED ON THE BUYPRICE OF THE PRODUCT SPECIFICED AND THE QUANTITY IN @PQTY
    -- UPDATE INVENTORY8393 FOR THE SPECIFIED PRODUCT IN THE SPECIFIED LOCATION BY THE QTY PURCHASED
    -- DECREASE THE ASSETCASH ROW IN THE GENERAL LEDGER BY THE TOTAL AMOUNT OF THE ORDER
    -- INCREASE THE ASSETSTOCK ROW IN THE GENERAL LEDGER BY THE TOTAL AMOUNT OF THE ORDER

    -- EXCEPTIONS
    -- if the LOCATUON id is invalid throw error: number 51002  message : 'LOCATION DOES NOT EXIST'
    -- if the PRODUCT id is invalid throw error: number 52002  message : 'PRODUCT DOES NOT EXIST'
    -- IF THERE IS INSUFFICIENT ASSETSCASH IN THE GENERAL LEDGER THEN THROW ERROR: 59001 MESSAGE : 'INSUFFICIENT CASH'
    -- for any other errors throw error : number 50000  message:  error_message()

    BEGIN TRY
        BEGIN TRANSACTION
            IF (SELECT COUNT(*) FROM LOCATION8393 WHERE LOCATIONID = @PLOCID) = 0
            THROW 51002, 'LOCATION DOES NOT EXIST', 1;
            IF (SELECT COUNT(*) FROM PRODUCT8393 WHERE PRODUCTID = @PPRODID) = 0
            THROW 52002, 'PRODUCT DOES NOT EXIST', 1;
            DECLARE @TOTAL INT = @PQTY * (SELECT BUYPRICE
                FROM PRODUCT8393
                WHERE @PPRODID = PRODUCTID)
            IF (SELECT AMOUNT FROM GENERALLEDGER8393 WHERE DESCRIPTION = 'ASSETSCASH') < @TOTAL
            THROW 59001, 'INSUFFICIENT CASH', 1;

            INSERT INTO PURCHASEORDER8393
            (PRODUCTID, LOCATIONID, QUANTITY, DATETIMECREATED, TOTAL)
            VALUES
            (@PPRODID, @PLOCID, @PQTY, CURRENT_TIMESTAMP, @TOTAL);

            UPDATE INVENTORY8393
            SET NUMINSTOCK = NUMINSTOCK + @PQTY
            WHERE (PRODUCTID = @PPRODID AND LOCATIONID = @PLOCID);

            UPDATE GENERALLEDGER8393
            SET AMOUNT = AMOUNT - @TOTAL
            WHERE DESCRIPTION = 'ASSETSCASH';

            UPDATE GENERALLEDGER8393
            SET AMOUNT = AMOUNT + @TOTAL
            WHERE DESCRIPTION = 'ASSETSSTOCK';
        COMMIT
    END TRY
    BEGIN CATCH
        IF ERROR_NUMBER() = 51002 OR ERROR_NUMBER() = 52002 OR ERROR_NUMBER() = 59001
            THROW;
        ELSE
            BEGIN
        DECLARE @ERRORMESSAGE NVARCHAR(MAX) = ERROR_MESSAGE();
        THROW 50000, @ERRORMESSAGE, 1;
    END;
    END CATCH;
END;

GO

IF OBJECT_ID('ADD_CLIENT_ACCOUNT') IS NOT NULL
DROP PROCEDURE ADD_CLIENT_ACCOUNT;

GO

CREATE PROCEDURE ADD_CLIENT_ACCOUNT 
@PACCTNAME NVARCHAR(100), 
@PBALANCE MONEY, 
@PCREDITLIMIT MONEY,
@ACCOUNTID INT OUTPUT
AS
BEGIN
    -- insert the specified values into the table CLIENTACCOUNT8393
    -- RETURN THE NEW ACCOUNTS ACCOUNTID

    -- EXCEPTIONS
    -- ACCOUNT NAME ALREADY EXISTS - SEE TABLE CONSTRAINTS - THROW ERROR 53001 : DUPLICATE ACCOUNT NAME
    -- for any other errors throw error : number 50000  message:  error_message()

    BEGIN TRY
        INSERT INTO CLIENTACCOUNT8393
        (ACCTNAME, BALANCE, CREDITLIMIT)
        VALUES
        (@PACCTNAME, @PBALANCE, @PCREDITLIMIT);
        SET @ACCOUNTID = SCOPE_IDENTITY();
    END TRY
    BEGIN CATCH
        IF ERROR_NUMBER() = 2627
            THROW 53001, 'DUPLICATE ACCOUNT NAME', 1;
        ELSE
            BEGIN
                DECLARE @ERRORMESSAGE NVARCHAR(MAX) = ERROR_MESSAGE();
                THROW 50000, @ERRORMESSAGE, 1;
            END;
    END CATCH;
END;

GO

IF OBJECT_ID('ADD_AUTHORISED_PERSON') IS NOT NULL
DROP PROCEDURE ADD_AUTHORISED_PERSON;

GO

CREATE PROCEDURE ADD_AUTHORISED_PERSON 
@PFIRSTNAME NVARCHAR(100),
@PSURNAME NVARCHAR(100),
@PEMAIL NVARCHAR(100),
@PPASSWORD NVARCHAR(100),
@PACCOUNTID INT,
@USERID INT OUTPUT
AS
BEGIN
    -- insert the specified values into the table AUTHORISEDPERSON8393
    -- RETURN THE NEW USERS USER ID

    -- EXCEPTIONS
    -- EMAIL IS INVALID (DOESN'T CONTAIN AN @ - SEE TABLE CONSTRAINTS)  - THROW ERROR 53003 : INVALID EMAIL ADDRESS
    -- for any other errors throw error : number 50000  message:  error_message()

    BEGIN TRY
        INSERT INTO AUTHORISEDPERSON8393
        (FIRSTNAME, SURNAME, EMAIL, [PASSWORD], ACCOUNTID)
        VALUES
        (@PFIRSTNAME, @PSURNAME, @PEMAIL, @PPASSWORD, @PACCOUNTID);
        SET @USERID = SCOPE_IDENTITY();
    END TRY
    BEGIN CATCH
        if ERROR_NUMBER() = 547 AND ERROR_MESSAGE() LIKE '%CHK_AUTHORISEDPERSON_EMAIL%'
            THROW 53003, 'INVALID EMAIL ADDRESS', 1;
        ELSE
            BEGIN
                DECLARE @ERRORMESSAGE NVARCHAR(MAX) = ERROR_MESSAGE();
                THROW 50000, @ERRORMESSAGE, 1;
            END;
    END CATCH;
END;

GO

IF OBJECT_ID('MAKE_ACCOUNT_PAYMENT') IS NOT NULL
DROP PROCEDURE MAKE_ACCOUNT_PAYMENT;

GO

CREATE PROCEDURE MAKE_ACCOUNT_PAYMENT
@PACCOUNTID INT,
@PAMOUNT MONEY
AS
BEGIN
    -- THE FOLLOWING MUST BE COMPLETED AS A SINGLE TRANSACTION
    -- insert the specified values into the table ACCOUNTPAYMENT8393 (USING THE CURRENT SYS DATETIME)
    -- UPDATE THE RELEVANT ACCOUNT IN CLENTACCOUNT8393 TO RELFECT THE BALANCE REDUCED BY THE PAYMENT
    -- UPDATE THE GENERAL LEDGER TO REDUCE ACCOUNT ASSETS BY THE PAYMENT AMOUNT
    -- UPDATE THE GENERAL LEDGER TO INCREASE CASH ASSETS BY THE PAYMENT AMOUNT

    -- EXCEPTIONS
    -- ACCOUNT DOES NOT EXIST THROW ERROR 53002 : ACCOUNT DOES NOT EXIST 
    -- PAYMENT AMOUNT IS NEGATIVE (SEE TABLE CONSTRAINTS) THROW ERROR 53004 :   ACCOUNT PAYMENT AMOUNT MUST BE POSITIVE  
    -- for any other errors throw error : number 50000  message:  error_message()

    BEGIN TRY
        BEGIN TRANSACTION
            IF (SELECT COUNT(*) FROM CLIENTACCOUNT8393 WHERE ACCOUNTID = @PACCOUNTID) = 0
            THROW 53002, 'ACCOUNT DOES NOT EXIST', 1;
            INSERT INTO ACCOUNTPAYMENT8393
            (ACCOUNTID, AMOUNT, DATETIMERECEIVED)
            VALUES
            (@PACCOUNTID, @PAMOUNT, CURRENT_TIMESTAMP);
            UPDATE CLIENTACCOUNT8393
            SET BALANCE = BALANCE - @PAMOUNT
            WHERE ACCOUNTID = @PACCOUNTID;
            UPDATE GENERALLEDGER8393
            SET AMOUNT = AMOUNT + @PAMOUNT
            WHERE DESCRIPTION = 'ASSETSCASH';
            UPDATE GENERALLEDGER8393
            SET AMOUNT = AMOUNT - @PAMOUNT
            WHERE DESCRIPTION = 'ASSETSACCOUNT';
        COMMIT
    END TRY
    BEGIN CATCH
        if ERROR_NUMBER() = 547 AND ERROR_MESSAGE() LIKE '%CHK_ACCOUNTPAYMENT_AMOUNT%'
            THROW 53004, 'ACCOUNT PAYMENT AMOUNT MUST BE POSITIVE', 1;
        ELSE IF ERROR_NUMBER() = 53002
            THROW;
        ELSE
            BEGIN
                DECLARE @ERRORMESSAGE NVARCHAR(MAX) = ERROR_MESSAGE();
                THROW 50000, @ERRORMESSAGE, 1;
            END;
    END CATCH;
END;

GO

IF OBJECT_ID('GET_CLIENT_ACCOUNT_BY_ID') IS NOT NULL
DROP PROCEDURE GET_CLIENT_ACCOUNT_BY_ID;

GO

CREATE PROCEDURE GET_CLIENT_ACCOUNT_BY_ID 
@PACCOUNTID INT,
@ACCTNAME NVARCHAR(100) OUTPUT,
@BALANCE MONEY OUTPUT,
@CREDITLIMIT MONEY OUTPUT
AS
BEGIN
    -- return the specified CLIENT ACCOUNT INCLUDING AND ALL AUTHORISED PERSONS DETAILS

    -- EXCEPTIONS
     -- ACCOUNT DOES NOT EXIST THROW ERROR 53002 : ACCOUNT DOES NOT EXIST 
    -- for any other errors throw error : number 50000  message:  error_message()
    
    BEGIN TRY
        IF (SELECT COUNT(*) FROM CLIENTACCOUNT8393 WHERE ACCOUNTID = @PACCOUNTID) = 0
        THROW 53002, 'ACCOUNT DOES NOT EXIST', 1;
        SELECT @ACCTNAME = ACCTNAME, @BALANCE = BALANCE, @CREDITLIMIT = CREDITLIMIT
        FROM CLIENTACCOUNT8393
        WHERE ACCOUNTID = @PACCOUNTID;
        SELECT * FROM AUTHORISEDPERSON8393
        WHERE ACCOUNTID = @PACCOUNTID;
    END TRY
    BEGIN CATCH
        if ERROR_NUMBER() = 2627
            THROW 50010, 'Duplicate customer ID', 1;
        ELSE IF ERROR_NUMBER() = 50020
            THROW;
        ELSE
            BEGIN
                DECLARE @ERRORMESSAGE NVARCHAR(MAX) = ERROR_MESSAGE();
                THROW 50000, @ERRORMESSAGE, 1;
            END;
    END CATCH;
END;

GO

IF OBJECT_ID('CREATE_ORDER') IS NOT NULL
DROP PROCEDURE CREATE_ORDER;

GO

CREATE PROCEDURE CREATE_ORDER
@PSHIPPINGADDRESS NVARCHAR(200),
@PUSERID INT,
@ORDERID INT OUTPUT
AS
BEGIN
    -- insert the specified values into the table ORDER8393
    -- SET THE TOTAL TO 0
    -- RETURN THE NEW ORDERS ORDERID

    -- EXCEPTIONS
    -- USER DOES NOT EXIST : THROW ERROR 55002 : USER DOES NOT EXIST
    -- for any other errors throw error : number 50000  message:  error_message()

    BEGIN TRY
        IF (SELECT COUNT(*) FROM AUTHORISEDPERSON8393 WHERE USERID = @PUSERID) = 0
        THROW 55002, 'USER DOES NOT EXIST', 1;

        INSERT INTO ORDER8393
        (SHIPPINGADDRESS, USERID, TOTAL, DATETIMECREATED)
        VALUES
        (@PSHIPPINGADDRESS, @PUSERID, 0, CURRENT_TIMESTAMP);

        SET @ORDERID = SCOPE_IDENTITY();
    END TRY
    BEGIN CATCH
        IF ERROR_NUMBER() = 55002
            THROW;
        ELSE
            BEGIN
                DECLARE @ERRORMESSAGE NVARCHAR(MAX) = ERROR_MESSAGE();
                THROW 50000, @ERRORMESSAGE, 1;
            END;
    END CATCH;
END;

GO

IF OBJECT_ID('GET_ORDER_BY_ID') IS NOT NULL
DROP PROCEDURE GET_ORDER_BY_ID;

GO

CREATE PROCEDURE GET_ORDER_BY_ID
@PORDERID INT
AS
BEGIN
    -- return the specified ORDER INCLUDING ALL RELATED ORDERLINES

    -- EXCEPTIONS
     -- ORDER DOES NOT EXIST THROW ERROR 54002 : ORDER DOES NOT EXIST 
    -- for any other errors throw error : number 50000  message:  error_message()

    BEGIN TRY
        IF (SELECT COUNT(*) FROM ORDER8393 WHERE ORDERID = @PORDERID) = 0
        THROW 54002, 'ORDER DOES NOT EXIST', 1;

        SELECT * FROM ORDER8393
        WHERE ORDERID = @PORDERID;

        SELECT * FROM ORDERLINE8393
        WHERE ORDERID = @PORDERID;
    END TRY
    BEGIN CATCH
        IF ERROR_NUMBER() = 54002
            THROW;
        ELSE
            BEGIN
                DECLARE @ERRORMESSAGE NVARCHAR(MAX) = ERROR_MESSAGE();
                THROW 50000, @ERRORMESSAGE, 1;
            END;
    END CATCH;
END;

GO

IF OBJECT_ID('ADD_PRODUCT_TO_ORDER') IS NOT NULL
DROP PROCEDURE ADD_PRODUCT_TO_ORDER;

GO

CREATE PROCEDURE ADD_PRODUCT_TO_ORDER
@PORDERID INT,
@PPRODIID INT,
@PQTY INT,
@DISCOUNT DECIMAL(5, 4)
AS
BEGIN
    -- THE FOLLOWING MUST BE COMPLETED AS A SINGLE TRANSACTION-------
    -- CHECK IF THE ORDER HAS ALREADY BEEN FULFILLED (HAS A DATETIMEDISATHCED VALUE)-----
    -- IF IT HAS BEEN FULFULLILLED GENERATE AN ERROR - SEE EXCEPTIONS SECTION---
    -- IF IT HAS NOT BEEN FULLFILLED THEN----
    -- IF THE PRODUCT HAS NOT ALREADY BEEN ADDED TO THAT ORDER (I.E. PK IS UNIQUE)
        -- insert the specified values into the table ORDERLINE8393
        -- CALCULATE THE SUBTOTAL VALUE BASED ON THE PRODUCTS SELLPRICE, THE QUANTITY AND THE DISCOUNT
        -- UPDATE THE ORDERS TOTAL - INCREASE IT BY THE VALUE OF THE ORDRLINES SUBTOTAL
    -- ELSE -- the product is aleady in that order 
        -- update the relevant orderline by adding the new quantity to the previous quantity,
        -- RE CALCULATE THE SUBTOTAL VALUE BASED ON THE PRODUCTS SELLPRICE, THE QUANTITY AND THE DISCOUNT
        -- UPDATE THE ORDERS TOTAL - INCREASE IT BY THE VALUE OF THE QTY ADDED TO THE ORDERLINE

    -- EXCEPTIONS
    -- ORDER DOES NOT EXIST THROW ERROR 54002 : ORDER DOES NOT EXIST 
    -- ORDER HAS ALREADY BEEN FULFILLED THROW ERROR 54003 : ORDER HAS ALRADY BEEN FULLFILLED
    -- PRODUCT DOES NOT EXIST THROW ERROR 52002 : PRODUCT DOES NOT EXIST
    -- DISCOUNT IS OUT OF PERMITTED RANGE (SEE TABLE CONSTRAINTS) THROW ERROR 54004 : DISCOUNT OUT OF RANGE
    -- for any other errors throw error : number 50000  message:  error_message()

    BEGIN TRY
        BEGIN TRANSACTION
            IF (SELECT COUNT(*) FROM ORDER8393 WHERE ORDERID = @PORDERID) = 0
            THROW 54002, 'ORDER DOES NOT EXIST', 1;
            IF (SELECT DATETIMEDISPATCHED FROM ORDER8393 WHERE ORDERID = @PORDERID) IS NOT NULL
            THROW 54002, 'ORDER HAS ALREADY BEEN FULLFILLED', 1
            IF (SELECT COUNT(*) FROM PRODUCT8393 WHERE PRODUCTID = @PPRODIID) = 0
            THROW 52002, 'PRODUCT DOES NOT EXIST', 1;
            IF (SELECT COUNT(*) FROM ORDERLINE8393 WHERE (PRODUCTID = @PPRODIID AND ORDERID = @PORDERID)) = 0
            BEGIN
                DECLARE @SUBTOTAL MONEY = @PQTY * (1 - @DISCOUNT) * (SELECT SELLPRICE FROM PRODUCT8393 WHERE PRODUCTID = @PPRODIID);

                INSERT INTO ORDERLINE8393
                (ORDERID, PRODUCTID, QUANTITY, DISCOUNT, SUBTOTAL)
                VALUES
                (@PORDERID, @PPRODIID, @PQTY, @DISCOUNT, @SUBTOTAL);

                UPDATE ORDER8393
                SET TOTAL = TOTAL + @SUBTOTAL
                WHERE ORDERID = @PORDERID;
            END;
            ELSE
            BEGIN
                UPDATE ORDERLINE8393
                SET QUANTITY = QUANTITY + @PQTY, DISCOUNT = @DISCOUNT
                WHERE (ORDERID = @PORDERID AND PRODUCTID = @PPRODIID);

                DECLARE @OLDSUBTOTAL MONEY = (SELECT SUBTOTAL FROM ORDERLINE8393 WHERE (ORDERID = @PORDERID AND PRODUCTID = @PPRODIID));

                UPDATE ORDERLINE8393
                SET SUBTOTAL = QUANTITY * (1 - @DISCOUNT) * (SELECT SELLPRICE FROM PRODUCT8393 WHERE PRODUCTID = @PPRODIID)
                WHERE (ORDERID = @PORDERID AND PRODUCTID = @PPRODIID);
                
                UPDATE ORDER8393
                SET TOTAL = TOTAL + (SELECT SUBTOTAL FROM ORDERLINE8393 WHERE (ORDERID = @PORDERID AND PRODUCTID = @PPRODIID)) - @OLDSUBTOTAL
                WHERE ORDERID = @PORDERID;
            END;
        COMMIT
    END TRY
    BEGIN CATCH
        if ERROR_NUMBER() = 547 AND ERROR_MESSAGE() LIKE '%CHK_ORDER_DISCOUNT%'
            THROW 54004, 'DISCOUNT OUT OF RANGE', 1;
        ELSE IF ERROR_NUMBER() = 54002 OR ERROR_NUMBER() = 52002 OR ERROR_NUMBER() = 54003
            THROW;
        ELSE
            BEGIN
                DECLARE @ERRORMESSAGE NVARCHAR(MAX) = ERROR_MESSAGE();
                THROW 50000, @ERRORMESSAGE, 1;
            END;
    END CATCH;
END;

GO

IF OBJECT_ID('REMOVE_PRODUCT_FROM_ORDER') IS NOT NULL
DROP PROCEDURE REMOVE_PRODUCT_FROM_ORDER;

GO

CREATE PROCEDURE REMOVE_PRODUCT_FROM_ORDER
@PORDERID INT,
@PPRODIID INT AS
BEGIN
    -- THE FOLLOWING MUST BE COMPLETED AS A SINGLE TRANSACTION
    -- CHECK IF THE ORDER HAS ALREADY BEEN FULFILLED (HAS A DATETIMEDISATHCED VALUE)
    -- IF IT HAS BEEN FULFULLILLED GENERATE AN ERROR - SEE EXCEPTIONS SECTION
    -- IF IT HAS NOT BEEN FULLFILLED THEN
    -- UPDATE THE ORDERS TOTAL - DECREASE IT BY THE VALUE OF THE ORDRLINES SUBTOTAL
    -- DELETE THE RELEVANT ROW FROM ORDERLINE8393

    -- EXCEPTIONS
    -- ORDER DOES NOT EXIST THROW ERROR 54002 : ORDER DOES NOT EXIST 
    -- ORDER HAS ALREADY BEEN FULFILLED THROW ERROR 54003 : ORDER HAS ALREADY BEEN FULLFILLED
    -- PRODUCT DOES NOT EXIST THROW ERROR 52002 : PRODUCT DOES NOT EXIST
    -- PRODUCT HAS NOT BEEN ADDED TO ORDER THROW ERROR 54005 : PRODUCT NOT ON ORDER
    -- for any other errors throw error : number 50000  message:  error_message()

    BEGIN TRY
        BEGIN TRANSACTION
            IF (SELECT COUNT(*) FROM ORDER8393 WHERE ORDERID = @PORDERID) = 0
            THROW 54002, 'ORDER DOES NOT EXIST', 1;
            IF (SELECT DATETIMEDISPATCHED FROM ORDER8393 WHERE ORDERID = @PORDERID) IS NOT NULL
            THROW 54002, 'ORDER HAS ALREADY BEEN FULLFILLED', 1;
            IF (SELECT COUNT(*) FROM PRODUCT8393 WHERE PRODUCTID = @PPRODIID) = 0
            THROW 52002, 'PRODUCT DOES NOT EXIST', 1;
            IF (SELECT COUNT(*) FROM ORDERLINE8393 WHERE (ORDERID = @PORDERID AND PRODUCTID = @PPRODIID)) = 0
            THROW 54005, 'PRODUCT NOT ON ORDER', 1;

            UPDATE ORDER8393
            SET TOTAL = TOTAL - (SELECT SUBTOTAL FROM ORDERLINE8393 WHERE (ORDERID = @PORDERID AND PRODUCTID = @PPRODIID))
            WHERE ORDERID = @PORDERID;

            DELETE FROM ORDERLINE8393
            WHERE (ORDERID = @PORDERID AND PRODUCTID = @PPRODIID);
        COMMIT
    END TRY
    BEGIN CATCH
        IF ERROR_NUMBER() = 54002 OR ERROR_NUMBER() = 52002 OR ERROR_NUMBER() = 54003 OR ERROR_NUMBER() = 54005
            THROW
        ELSE
            BEGIN
                DECLARE @ERRORMESSAGE NVARCHAR(MAX) = ERROR_MESSAGE();
                THROW 50000, @ERRORMESSAGE, 1;
            END;
    END CATCH;
END;

GO

IF OBJECT_ID('GET_OPEN_ORDERS') IS NOT NULL
DROP PROCEDURE GET_OPEN_ORDERS;

GO

CREATE PROCEDURE GET_OPEN_ORDERS AS
BEGIN
    -- RETURN A CURSOR WHICH REFERENCES ALL CURRENTLY OPEN (NOT FULFILLED) ORDERS

    -- EXCEPTIONS
    -- for any other errors throw error : number 50000  message:  error_message()

    BEGIN TRY
        SELECT * FROM ORDER8393
        WHERE DATETIMEDISPATCHED IS NULL;
    END TRY
    BEGIN CATCH
        DECLARE @ERRORMESSAGE NVARCHAR(MAX) = ERROR_MESSAGE();
        THROW 50000, @ERRORMESSAGE, 1;
    END CATCH;
END;

GO

IF OBJECT_ID('FULLFILL_ORDER') IS NOT NULL
DROP PROCEDURE FULLFILL_ORDER;

GO

CREATE PROCEDURE FULLFILL_ORDER
@PORDERID INT
AS
BEGIN
    -- THE FOLLOWING MUST BE COMPLETED AS A SINGLE TRANSACTION

    -- CHECK IF THE ORDER HAS ALREADY BEEN FULFILLED (HAS A DATETIMEDISATHCED VALUE)
    -- IF IT HAS BEEN FULFULLILLED GENERATE AN ERROR - SEE EXCEPTIONS SECTION
    -- IF IT HAS NOT BEEN FULLFILLED THEN

    -- UPDATE THE ORDERS DATETIMEDISPATCHED WITH THE CURRENT DATE TIME
    -- ** TRICKY** FOR EACH PRODUCT IN THE ORDER FIND INVENTORY WHICH HAS SUFFICIENT UNITS OF THE PRODUCT IN STOCK 
            -- AND DECREASE THE INVENTORY BY THE AMOUNT OF THE PRODUCT IN TH ORDER
    -- INCREASE THE RELEVANT CLIENTACCOUNTS BALANCE BY THE TOTAL VALUE OF THE ORDER
    -- INCREASE THE GENERAL LEDGER ACCOUNT ASSETS AMOUNT BY THE TOTAL VALUE OF THE ORDER
    -- ** TRICKY** DECREASE THE GENERAL LEDGER STOCK ASSESTS AMOUNT BY THE WHOLESALE (QTY * BUYPRICE) OF ALL THE PRODUCTS IN THE ORDER

    -- EXCEPTIONS
    -- INSUFFICIENT INVENTORY OF ONE OR MORE PRODUCTS TO FULFILL ORDER THROW ERROR 54006: INSUFFUCIENT INVENTORY TO FULFILL
	-- CLIENT ACCOUNT DOES NOT HAVE SUFFICIENT CREDIT REMAINING TO PAY FOR ORDER THROW ERROR 53005 : INSUFFICIENT CREDIT
    -- ORDER HAS ALREADY BEEN FULFILLED THROW ERROR 54003 : ORDER HAS ALREADY BEEN FULLFILLED
    -- ORDER DOES NOT EXIST THROW ERROR 54002 : ORDER DOES NOT EXIST 
    -- for any other errors throw error : number 50000  message:  error_message()

    BEGIN TRY
        BEGIN TRANSACTION
            IF (SELECT COUNT(*) FROM ORDER8393 WHERE ORDERID = @PORDERID) = 0
            THROW 54002, 'ORDER DOES NOT EXIST', 1;
            IF (SELECT DATETIMEDISPATCHED FROM ORDER8393 WHERE ORDERID = @PORDERID) IS NOT NULL
            THROW 54003, 'ORDER HAS ALREADY BEEN FULLFILLED', 1;

            DECLARE @ACCOUNTID INT, @TOTAL MONEY, @BALANCE MONEY, @CREDITLIMIT MONEY;
            SELECT @ACCOUNTID = C.ACCOUNTID, @TOTAL = O.TOTAL, @CREDITLIMIT = C.CREDITLIMIT, @BALANCE = C.BALANCE
            FROM CLIENTACCOUNT8393 AS C, ORDER8393 AS O, AUTHORISEDPERSON8393 AS A
            WHERE (O.ORDERID = @PORDERID AND O.USERID = A.USERID AND A.ACCOUNTID = C.ACCOUNTID);

            IF @TOTAL > @CREDITLIMIT - @BALANCE
            THROW 53005, 'INSUFFICIENT CREDIT', 1;

            UPDATE CLIENTACCOUNT8393
            SET BALANCE = BALANCE + @TOTAL
            WHERE ACCOUNTID = @ACCOUNTID;

            UPDATE GENERALLEDGER8393
            SET AMOUNT = AMOUNT + @TOTAL
            WHERE [DESCRIPTION] = 'ASSETSACCOUNT';

            UPDATE ORDER8393
            SET DATETIMEDISPATCHED = CURRENT_TIMESTAMP
            WHERE ORDERID = @PORDERID;

            DECLARE ORDERLINES CURSOR FOR
            SELECT PRODUCTID, QUANTITY FROM ORDERLINE8393
            WHERE ORDERID = @PORDERID;

            DECLARE @PRODUCTID INT, @QUANTITY INT;

            OPEN ORDERLINES;
            
            FETCH NEXT FROM ORDERLINES
            INTO @PRODUCTID, @QUANTITY;

            WHILE @@FETCH_STATUS = 0
            BEGIN
                IF (SELECT Count(*) FROM INVENTORY8393
                WHERE PRODUCTID = @PRODUCTID AND NUMINSTOCK >= @QUANTITY) = 0
                THROW 54006, 'INSUFFUCIENT INVENTORY TO FULFILL', 1;

                WITH UpdateList_view AS (
                    SELECT TOP 1 * from INVENTORY8393 
                    WHERE PRODUCTID = @PRODUCTID AND NUMINSTOCK >= @QUANTITY
                    ORDER BY NUMINSTOCK DESC 
                )
                UPDATE UpdateList_view 
                SET NUMINSTOCK = NUMINSTOCK - @QUANTITY;

                UPDATE GENERALLEDGER8393
                SET AMOUNT = AMOUNT - @QUANTITY * (SELECT BUYPRICE FROM PRODUCT8393 WHERE PRODUCTID = @PRODUCTID)
                WHERE [DESCRIPTION] = 'ASSETSSTOCK';

                FETCH NEXT FROM ORDERLINES
                INTO @PRODUCTID, @QUANTITY;
            END;

            CLOSE ORDERLINES;
            DEALLOCATE ORDERLINES;
            
        COMMIT
    END TRY
    BEGIN CATCH
        if ERROR_NUMBER() = 2627
            THROW 50010, 'Duplicate customer ID', 1;
        ELSE IF ERROR_NUMBER() = 54006 OR ERROR_NUMBER() = 53005 OR ERROR_NUMBER() = 54002 OR ERROR_NUMBER() = 54003
            THROW;
        ELSE
            BEGIN
                DECLARE @ERRORMESSAGE NVARCHAR(MAX) = ERROR_MESSAGE();
                THROW 50000, @ERRORMESSAGE, 1;
            END;
    END CATCH;
END;

GO

-- TESTING

BEGIN

    -- SET UP LOCATION, PRODUCT AND INVENTORY

    EXEC ADD_LOCATION @PLOCID = 'MLB3931', @PLOCNAME = 'Melbourne South East', @PLOCADDRESS = '123 Demon Street, Mornington, 3931', @PMANAGER = 'Bruce Wayne';
    EXEC ADD_LOCATION @PLOCID = 'MLB3500', @PLOCNAME = 'The Basement', @PLOCADDRESS = '456 Eat Street, Evenington, 3500', @PMANAGER = 'Greg Down The Road';

    DECLARE @PRODID1 INT, @PRODID2 INT, @PRODID3 INT;

    EXEC ADD_PRODUCT 'APPLE ME PHONE X', 890.00, 1295.00, @PRODID1 OUTPUT;
    EXEC ADD_PRODUCT 'ANDRONG', 500.00, 1009.00, @PRODID2 OUTPUT;
    EXEC ADD_PRODUCT 'CEMENT', 30.00, 50.00, @PRODID3 OUTPUT;

    DECLARE @ACCOUNTID INT;

    EXEC ADD_CLIENT_ACCOUNT 'FREDS LOCAL PHONE STORE', '0', 20000.00, @ACCOUNTID OUTPUT;

    DECLARE @USERID INT;

    EXEC ADD_AUTHORISED_PERSON 'Fred', 'Flintstone', 'fred@fredsphones.com', 'secret', @ACCOUNTID, @USERID OUTPUT;

    -- BUY SOME STOCK

    EXEC PURCHASE_STOCK @PRODID1, 'MLB3931', 50;
    EXEC PURCHASE_STOCK @PRODID2, 'MLB3500', 50;
    EXEC PURCHASE_STOCK @PRODID3, 'MLB3931', 50;

    -- CUSTOMER MAKES AN ORDER - (INITIALLY THE ORDER IS NOT FULFILLED)

    DECLARE @ORDERID1 INT;
    DECLARE @ORDERID2 INT;

    EXEC CREATE_ORDER '7 Lucky Strike, Bedrock, USB, 1111', @USERID, @ORDERID1 OUTPUT;
    EXEC CREATE_ORDER 'AAAAAAA', @USERID, @ORDERID2 OUTPUT;

    EXEC ADD_PRODUCT_TO_ORDER @ORDERID1, @PRODID1, 5, 0.05;
    EXEC ADD_PRODUCT_TO_ORDER @ORDERID1, @PRODID2, 4, 0.00;
    EXEC ADD_PRODUCT_TO_ORDER @ORDERID1, @PRODID3, 43, 0.1;

    EXEC ADD_PRODUCT_TO_ORDER @ORDERID2, @PRODID3, 3, 0.1;

    EXEC FULLFILL_ORDER @ORDERID1;

    -- CLIENT MAKES AN ACCOUNT OFF THIER ACCOUNT BALANCE

    EXEC MAKE_ACCOUNT_PAYMENT @ACCOUNTID, 12122.25;

END;

GO